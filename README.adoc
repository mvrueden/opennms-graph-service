= OpenNMS Graph Service Proof of Concept

The goal is to provide some new thing in to OpenNMS which is the single line of access to all Graph related operations.
The working title of this thing is `Graph Service`.

== Terminology

A *Graph* consists of any number of points with any number of connections in between.
Usually these points are called *Nodes*, but as *Nodes* have a specific meaning in OpenNMS in the context of the `Graph Service` they are called *Vertices* (plural of *Vertex*).
The connection between two *Vertices* are usually called *Link*, however it also has a specific meaning inside OpenNMS, thus it is called *Edge*.
The following figure shows a *Graph* with five *Vertices* and four *Edges*.

image::https://wiki.opennms.org/wiki/images/3/30/Toplogy-graph.png[]

== Dilema

As the general concept of a graph with vertices and edges is pretty simple, each use case the graph represents may not be that trivial.
This leads to a very generic `Graph Model`, but on the other hand a very specific implementation.
This means the `Graph Model` should be easily shared between modules and applications (e.g. for visualization) but also
be able to be used for specific use-cases.
For example the BSM and Enlinkd model would share the same generic model, but under the hood be able to store specific information, thus allowing to write e.g. a very generic UI.

== Rules

Based on the dilemma, the following rules apply to provide a very loose model, but be able to provide full flexibility for implemtnations.

 - Each Graph must be uniquely identified.
   This identifier is called a `namespace`.
 - Each Vertex and Edge must be uniquely identified by an identifier.
   This identifier is called an `id`.
 - Each Vertex and Edge have the same `namespace` as the Graph they are part of.
 - Each Graph, Vertex or Edge have additional properties to define their nature in more detail.
   E.g. a Vertex may contain a `label`, `node` or `location` property.
 - Each Edge contains the source and target id of the Vertex it connects, therefore is ALWAYS directed.

== Notes

=== Events
* Build a graph via Events (AddVertexEvent, AddEdgeEvent, etc.)
* Each event should contain the concrete implementation of a vertex or edge, e.g. BsmVertex vs. VmwareVertex, etc.
* However, they all should be a GenericVertex/Edge in the end
* If adding, updating and removing is supported, implementing update is tricky for services, e.g. VmwareImporter
** Basically, when is graph creation finished to decide if nodes should be removed or added.
   E.g. VmwareImporter runs twice a day and previous nodes must all be removed. Logic of that must live then in the Importer, which will probably lead
   to a general "RemoveVertexEvent" for all existing vertices, which kinda contradicts the whole purpose
   Proposal: Lifecycle, with events: GraphCreationStartedEvent/GraphCreationEndEvent to indicate a new "import".
   However, this leads to the problem, that the importer must know how to create the graph.
* Also when building the Graph, it should be possible to have access to the currently build one (vertices and eges)
  With current approach not easily done.
* The old "StatusProvider" logic could either be implemented using the Enrichment mechanism (see below) or an "Enrichment/Update"-Event in order to update the state of a vertex
  E.g a graph could listen for "NodeDown"-Events and mark a vertex as down accordingly.

=== Multiple Graphs (e.g. Navigate To)

As of now, it is not decided if a GraphProvider can provide multiple graphs, however:

Each graph only contains vertices and edges with the same namespace.
Any edge may point to or from a vertex with a different namespace (This namespace may or may not exist yet in the GraphRepository).
If one side of the edge is pointing to another namespace, the opposite vertex must be of the same namespace as the graph the edge is "owned" by.

=== Searching

The "GraphProvider" should implement some kind of search mechanism, which provides search suggestions without querying the graph itself.

=== Enrichment (Thoughts)

An "Enrichment" process should be implemented in order to help resolving a Node, Interface, etc.
This should be implemented at a higher level, to allow caching of some sort.
Something like this should be possible

[source, Java]
----
SimpleVertex v = new SimpleVertex();
v.withNode(NodeRef.from(node));

// ...

v.withInterface(node.getIpInterfaces().get(0));
----

Afterwards when converting this to a GenericVertex, NodeInfo or IpInterface snippets are put onto the vertex.
Another more general concept could look like this:

[source, Java]
----
interface EnrichmentProvider<V extends Vertex, E extends Edge<V>> {
   boolean contributesTo(String namespace);
   void enrich(V vertex);
   void enrich(E edge);
}
----

A NodeEnrichmentProvider could then enrich vertices or edges with node information if a `nodeRef` attribute is defined,
resolving either by node id or location:foreignSource:foreignId.

=== UI

In the original topology implementation, vertices and eges contain ui information, such as tooltip or icons, etc.
However this should be implemented in the ui layer itself, e.g. a renderer for each namespace/vertex/edge.
Meaning, each vertex or edge should contain enough information to visualize it accordingly.
