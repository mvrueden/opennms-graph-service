= OpenNMS Graph Service Proof of Concept

The goal is to provide some new thing in to OpenNMS which is the single line of access to all Graph related operations.
The working title of this thing is `Graph Service`.

== Terminology

A *Graph* consists of any number of points with any number of connections in between.
Usually these points are called *Nodes*, but as *Nodes* have a specific meaning in OpenNMS in the context of the `Graph Service` they are called *Vertices* (plural of *Vertex*).
The connection between two *Vertices* are usually called *Link*, however it also has a specific meaning inside OpenNMS, thus it is called *Edge*.
The following figure shows a *Graph* with five *Vertices* and four *Edges*.

image::https://wiki.opennms.org/wiki/images/3/30/Toplogy-graph.png[]

== Dilema

As the general concept of a graph with vertices and edges is pretty simple, each use case the graph represents may not be that trivial.
This leads to a very generic `Graph Model`, but on the other hand a very specific implementation.
This means the `Graph Model` should be easily shared between modules and applications (e.g. for visualization) but also
be able to be used for specific use-cases.
For example the BSM and Enlinkd model would share the same generic model, but under the hood be able to store specific information, thus allowing to write e.g. a very generic UI.

== Rules

Based on the dilemma, the following rules apply to provide a very loose model, but be able to provide full flexibility for implemtnations.

 - Each Graph must be uniquely identified.
   This identifier is called a `namespace`.
 - Each Vertex and Edge must be uniquely identified by an identifier.
   This identifier is called an `id`.
 - Each Vertex and Edge have the same `namespace` as the Graph they are part of.
 - Each Graph, Vertex or Edge have additional properties to define their nature in more detail.
   E.g. a Vertex may contain a `label`, `node` or `location` property.
 - Each Edge contains the source and target id of the Vertex it connects, therefore is ALWAYS directed.

== Notes

=== Events
* Build a graph via Events (AddVertexEvent, AddEdgeEvent, etc.)
* Each event should contain the concrete implementation of a vertex or edge, e.g. BsmVertex vs. VmwareVertex, etc.
* However, they all should be a GenericVertex/Edge in the end
* If adding, updating and removing is supported, implementing update is tricky for services, e.g. VmwareImporter
** Basically, when is graph creation finished to decide if nodes should be removed or added.
   E.g. VmwareImporter runs twice a day and previous nodes must all be removed. Logic of that must live then in the Importer, which will probably lead
   to a general "RemoveVertexEvent" for all existing vertices, which kinda contradicts the whole purpose
   Proposal: Lifecycle, with events: GraphCreationStartedEvent/GraphCreationEndEvent to indicate a new "import".
   However, this leads to the problem, that the importer must know how to create the graph.
* Also when building the Graph, it should be possible to have access to the currently build one (vertices and eges)
  With current approach not easily done.
* The old "StatusProvider" logic could either be implemented using the Enrichment mechanism (see below) or an "Enrichment/Update"-Event in order to update the state of a vertex
  E.g a graph could listen for "NodeDown"-Events and mark a vertex as down accordingly.

=== Multiple Graphs (e.g. Navigate To)

As of now, it is not decided if a GraphProvider can provide multiple graphs, however:

Each graph only contains vertices and edges with the same namespace.
Any edge may point to or from a vertex with a different namespace (This namespace may or may not exist yet in the GraphRepository).
If one side of the edge is pointing to another namespace, the opposite vertex must be of the same namespace as the graph the edge is "owned" by.

=== Searching

The "GraphProvider" should implement some kind of search mechanism, which provides search suggestions without querying the graph itself.

=== Enrichment (Thoughts)

An "Enrichment" process should be implemented in order to help resolving a Node, Interface, etc.
This should be implemented at a higher level, to allow caching of some sort.
Something like this should be possible

[source, Java]
----
SimpleVertex v = new SimpleVertex();
v.withNode(NodeRef.from(node));

// ...

v.withInterface(node.getIpInterfaces().get(0));
----

Afterwards when converting this to a GenericVertex, NodeInfo or IpInterface snippets are put onto the vertex.
Another more general concept could look like this:

[source, Java]
----
interface EnrichmentProvider<V extends Vertex, E extends Edge<V>> {
   boolean contributesTo(String namespace);
   void enrich(V vertex);
   void enrich(E edge);
}
----

A NodeEnrichmentProvider could then enrich vertices or edges with node information if a `nodeRef` attribute is defined,
resolving either by node id or location:foreignSource:foreignId.

=== UI

In the original topology implementation, vertices and eges contain ui information, such as tooltip or icons, etc.
However this should be implemented in the ui layer itself, e.g. a renderer for each namespace/vertex/edge.
Meaning, each vertex or edge should contain enough information to visualize it accordingly.

=== Problems

- GenericGraph => specific Graph (e.g. SimpleGraph) conversion when persisting is a problem
- Also when loading data from a repository (e.g. database) the graph info is not yet available, what to do in this case?

=== Performance

All measurements are very rough, on a not optimized system with a not optimized postgresql

- Writing a graph with 100k nodes and 100k edges takes roughly about 1 Minute.
  Where conversion from Graph -> GenericGraph takes half a second and the conversion from the GenericGraph to a GraphEntity roughly the same amount of time
  Afterwards persisting takes ~30-40 seconds and flushing the session again ~30-60 seconds.
- Loading the same graph takes about 35 (not enriching the graph with node information)
  ` Reloaded [nodes-performance] in 33218 ms`.
  In comparison loading all nodes takes about 50 seconds `Reloaded [nodes] in 48179 ms`.
  However that only loads the `OnmsNode` object, not including lazy loading relations, such as categories or ip interfaces.
- Searching for attributes of vertices in the graph  with 100k nodes will return very quickly (no performance impact detected)
- Searching for categories which match 60% of the graph will return also very quickly (however the noderef vertex association is cached in the graph, otherwise it takes forever)

=== Generate Graph
The `GenerateGraphTest` will create a graph, as follows:

 * Create a Router Node
   * Name `Router <index>`
   * Add to Category `Routers,Test,Production,Development`
   * Add 5 interfaces
 * For each Router create 3 servers
    * Name `Server <index>`
    * Add all to Category `Servers`
    * Add one to Category `Test`
    * Add one to Category `Production`
    * Add one to Category `Development`
 * For each Router create 1 printer
    * Name `Printer <index>`
    * Add to category `Printers`
    * Add to category `Test,Production,Development`


At the end, create a graph based on the node definition above.
Afterwards all Routers are connected to a dummy vertex.
So the graph generated consists of `5 * ROUTER_NODE_COUNT + 1` vertices and `5 * ROUTER_NODE_COUNT` edges.

=== SQL to create tables

[source, sql]
----
drop table if exists graph_elements cascade;
drop table if exists graph_attributes cascade;
drop table if exists graph_elements_relations cascade;

create table graph_elements (
  id        bigint primary key,
  type      varchar not null,
  namespace varchar,
  source_vertex_id bigint,
  target_vertex_id bigint
);
alter table graph_elements add constraint fk_source_vertices foreign key (source_vertex_id) REFERENCES graph_elements (id) ON DELETE CASCADE ON UPDATE CASCADE;
alter table graph_elements add constraint fk_target_vertices foreign key (target_vertex_id) REFERENCES graph_elements (id) ON DELETE CASCADE ON UPDATE CASCADE;
CREATE INDEX idx_fk_source_vertices ON graph_elements (source_vertex_id);
CREATE INDEX idx_fk_target_vertices ON graph_elements (target_vertex_id);

create table graph_attributes (
  id bigint primary key,
  name varchar not null,
  type varchar not null,
  value varchar,
  element_id bigint
);
alter table graph_attributes add constraint fk_graph_attributes_element_id foreign key (element_id) REFERENCES graph_elements (id) ON DELETE CASCADE ON UPDATE CASCADE;
CREATE INDEX idx_fk_graph_attributes_element_id ON graph_attributes (element_id);

create table graph_elements_relations (
  graph_id bigint ,
  element_id bigint,
  PRIMARY KEY(graph_id, element_id)
);
alter table graph_elements_relations add constraint fk_graph_elements_relations_graph_id foreign key (graph_id) REFERENCES graph_elements (id) ON DELETE CASCADE ON UPDATE CASCADE;
alter table graph_elements_relations add constraint fk_graph_elements_relations_element_id foreign key (element_id) REFERENCES graph_elements (id) ON DELETE CASCADE ON UPDATE CASCADE;
CREATE INDEX idx_fk_graph_elements_relations_graph_id ON graph_elements_relations (graph_id);
CREATE INDEX idx_fk_graph_elements_relations_element_id ON graph_elements_relations (element_id);
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO opennms;
----